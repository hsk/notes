# 完全なプログラムを設計してコードを書く方法(翻訳) #
関数型アプリケーションのレシピ パート1

原文：[How to design and code a complete program][link01]

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

「自分ではミクロレベルで関数型プログラミングが分かってきていて、小さなプログラムくらいは作成できるようになったんだけれど、どうしたら実際のデータを処理したり、現実的なエラー処理を実行するような完全なプログラムを作成できるようになるんだろう？」

これは非常によくある疑問です。
そこで私は以降の一連の記事において設計やバリデーション、エラー処理、一貫性、依存性の管理、コードの構成など、完全なプログラムを作成するために必要なレシピを解説していこうと思っています。

先にいくつかコメントしておきましょう。

* この連載ではアプリケーション全体というよりは1つのユースケースに焦点を絞ります。
  そうすればきっと必要に応じてコードを拡張できるはずです。
* 特別なトリックや高級なテクニックが必要にならないように、あえて極めて単純なデータフロー指向のレシピだけを取り上げます。
  ただしまだ初心者だという方に向けては、想定通りの結果が得られるように直感的な手順を用意したほうがよいだろうと思っています。
  それが唯一の正しい方法だと言うつもりはありません。
  異なる状況では異なるレシピが必要になるものであり、当然ながら読者のスキルが向上すればもっと単純で限定的なレシピを見つけ出すこともできるはずです。
* オブジェクト指向から簡単に移行できるように、「パターン(patterns)」や「サービス(services)」、「依存性の注入(dependency injection)」といったおなじみの概念を使用して、それらが関数型の概念とどのように対応するのかということを説明していくつもりです。
* また、今回のレシピはある意味命令的で、きちんとしたステップバイステップ形式の作業手順になっています。
  この方法がOOからFPへとスムーズに移行できるようなアプローチであればよいのですが。
* 話を簡単にするために（また単純なF#スニペットとして利用可能なように）、全体的なインフラ用モックを使用して、UIを直接操作しないものとします。

## 概要 ##

今回の連載でカバーする予定のものはおよそ以下の通りです：

* ユースケースを関数へと変換する。
  今回のパート1では単純なユースケースをどのようにすれば関数的なアプローチで実装できるのかといった話を説明します。
* [小さな関数を連結させる][link02]。
  次回は比喩を交えながら小さな関数を連結させて大きな関数にするという話をする予定です。
* 型駆動の設計と失敗型について。
  パート3ではユースケースに必要となる型を作成する方法と、失敗ケースに使用できるような特別なエラー型の使用方法を説明します。
* 構成と依存性の管理について。
  この回ではすべての関数を結びつける方法について説明します。
* 検証について。
  この回では検証機能を実装する様々な方法、ならびにアンセーフな外部の世界にあるものを型安全で柔軟な世界のものへと変換する方法について説明します。
* インフラストラクチャについて。
  この回ではロギングや外部コード連携など、様々なインフラ用コンポーネントについて説明します。
* ドメイン層について。
  この回では関数型の環境において、ドメイン駆動デザインがどのように機能するのかについて説明します。
* プレゼンテーション層について。
  この回では結果やエラーをUIに反映させる方法について説明します。
* 仕様変更への対応について。
  この回では仕様変更への対応と、それがコードに与える影響について説明します。

## はじめに ##

まずはWebサービス経由で顧客の情報を更新するという、とても単純なユースケースから始めましょう。

基本的な要求仕様としては以下の通りです：

* ユーザーが何かデータを送信する（ユーザーID、名前、メールアドレス）
* 名前とメールアドレスが正しいものかチェックする
* データベース内の適切なユーザーレコードを新しい名前とメールアドレスで更新する
* メールアドレスが変更された場合は確認用メールをアドレス宛に送信する
* 操作の結果をユーザーに表示する

これはよくあるデータ中心(data centric)のユースケースです。
ユースケースのトリガーとなるような何かしらのリクエストがあって、それがステム内で「受け渡されて」いき、各ステップにおいて何かしらの処理が実行されます。
この種のシナリオはエンタープライズ向けのソフトでよくあることで、今回の例に採用したのもそれが理由です。

各種コンポーネントのダイアグラムは以下の通りです：

![Happy path diagram][link03]

しかしここには「成功パス」しか書かれていません。
現実はそれほど単純ではないです！
ユーザーIDがデータベースに見つからなかった場合や、メールアドレスが不正だった場合、あるいはデータベースでエラーが起きた場合には何が起こるのでしょう？

エラーが発生した場合も考慮したダイアグラムになるように更新しましょう。

![Error path diagram][link04]

このように、ユースケースの各手順では様々なエラーが起こりえます。
これらのエラーをどうすればエレガントな方法で処理できるのか説明するというのが今回の1つのゴールです。

## 関数的に思考する ##

さて、ユースケースの各ステップが把握できたわけですが、どうすれば関数的なアプローチで解決策を設計していけるのでしょうか？

兎にも角にも、オリジナルのダイアグラムと関数的な思考とのミスマッチを確認する必要があります。

ユースケースでは一般的なリクエスト/レスポンスモデルを想定しています。
リクエストが送信されるとレスポンスが返されるというものです。
何か問題が発生したら処理が省略されて、レスポンスを「早々に」返します。

これを簡略化しつつダイアグラムにすると以下のようになります：

![Simplified diagram 01][link05]

しかし関数型モデルにおいて、関数とは以下のように入力と出力を行うブラックボックスのようなものです：

![Black box function][link06]

このモデルをユースケースに適用するにはどうしたらよいでしょう？

### 前方のみのフロー ###

まず、関数型データは前方のみにフローするということを認識する必要があります。
Uターンしたり途中でリターンしたりすることはできません。

今回の場合は成功パスを通らないのであればすべてのエラーが必ず前方から後方へと送られるということです。

![Error must be sent forward to the end][link07]

それがわかれば、今度はフロー全体を以下のように「ブラックボックス」関数へと変換できます：

![A function representing the use case][link08]

しかし当然ながらこの大きな関数の中身はそれぞれの処理を実行する小さな関数がパイプライン上に連結されたものになっています（関数的には「関数合成」と呼ばれるものです）。

![A big function composed from smaller functions][link09]

### エラー処理 ###

直前のダイアグラムでは1つの成功出力と3つのエラー出力がありました。
関数は1つしか結果を返せないわけで、4つは多すぎです！

ではどうすればよいでしょうか？

答えは、起こりうる出力それぞれを表現できるようなユニオン型を使用することです。
そうすれば処理全体を表す関数としては出力を1つにすることができます。

出力型の1例は以下の通りです：

```fsharp
type UseCaseResult =
    | Success
    | ValidationError
    | UpdateError
    | SmtpError
```

また、4つの出力を1つにまとめたダイアグラムは以下のようになります：

![A function returns a union type][link10]

### エラー処理を単純化する ###

これで問題が解決できそうですが、フロー中の処理毎にエラーを用意していたのでは脆弱な上に再利用性にも問題があります。
もっと改善できないものでしょうか？

もちろんできます！
本当に必要なのは2つのケースだけです。
以下のように、1つは成功パス用、そしてもう1つはその他すべてのエラーパス用があれば十分です：

```fsharp
type UseCaseResult =
    | Success
    | Failure
```

![A function returns two cases][link11]

この型は非常に汎用的で、どんなワークフローであっても利用できます！
この型を利用するような便利な機能の揃ったすばらしいライブラリを実際に作成できることがわかるはずですし、ほとんどのシナリオで再利用できます。

ただしもう1つ考慮すべき点があります。
このままでは成功/失敗のステータスがわかるだけで、結果としては何のデータも得られません。
そこでもう少し手を加えて、成功または失敗時における実際のデータを持たせることができるようにしましょう。
単にジェネリック（またの名は型引数）を使用して成功型と失敗型を指定するだけです。

最終的なジェネリックかつ再利用可能なバージョンは以下の通りです：

```fsharp
type Result<'TSuccess, 'TFailure> =
    | Success of 'TSuccess
    | Failure of 'TFailure
```

実のところ、F#ライブラリにはこの型と全く同じ役割をする型があります。
それが[Choice][link12]です。
しかし今回と次回の記事ではわかりやすいように上で定義した``Result``型を使い続けることとします。
もう少しきちんとしたコーディングが必要になった時点でChoiceを使用することにしましょう。

さて、それでは各手順を再度見てみると、各手順で発生したエラーを1つの「失敗」パスとして連結する必要があることがわかります。

![Combine to a single "failure" path][link13]

その方法については次の記事で説明することにしましょう。

## 総括とガイドライン ##

今のところ、以下のようなレシピ用のガイドラインがあります：

ガイドライン
* 各ユースケースは1つの関数になる
* ユースケース関数は``Success``と``Failure``のケースを持ったユニオン型1つを返す
* ユースケース関数は各データ処理を表す小さな関数の組み合わせになっている
* 各処理で発生したエラーは1つの失敗パスとして組み合わされる

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

| 前回 | 次回                                |
|:-----|------------------------------------:|
|      |[2. 鉄道指向プログラミング→][link14]|

[link01]: http://fsharpforfunandprofit.com/posts/recipe-part1/ "How to design and code a complete program"
[link02]: http://fsharpforfunandprofit.com/posts/recipe-part2/ "Railway oriented programming"
[link03]: img/01-01.png "Figure 01-01.png"
[link04]: img/01-02.png "Figure 01-02.png"
[link05]: img/01-03.png "Figure 01-03.png"
[link06]: img/01-04.png "Figure 01-04.png"
[link07]: img/01-05.png "Fiugre 01-05.png"
[link08]: img/01-06.png "Figure 01-06.png"
[link09]: img/01-07.png "Figure 01-07.png"
[link10]: img/01-08.png "Figure 01-08.png"
[link11]: img/01-09.png "Figure 01-09.png"
[link12]: http://msdn.microsoft.com/ja-jp/library/ee353439.aspx "Core.Choice<'T1, 'T2> 共用体"
[link13]: img/01-10.png "Figure 01-10.png"
[link14]: Railway%20oriented%20programming.md "Railway oriented programming"
