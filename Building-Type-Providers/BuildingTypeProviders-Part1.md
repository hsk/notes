型プロバイダーの作成 パート1 (翻訳)
==============================

(原文：[Building Type Providers - Part 1][id00])

型プロバイダーはF# 3.0における主要な新機能の1つです。
この機能を使用することにより、一般的には動的言語や文字列による型付けが行われるような領域において静的な型付けを行うことができるようになります。
百聞は一見にしかず、というわけで以下にある12枚の画像から型プロバイダーが実際に動作している様子が確認できます：

[All your types are belong to us][id01]

型プロバイダーを使用するサンプルや記事についてはこれまでにも多数公開されていますが、型プロバイダーを作成する記事についてはまだそれほど多くありません。
そこで私は [FSharp.Data][id02] での直近の作業を生かして、型プロバイダーの作成におけるTipsを共有しようと決めたわけです。

- - - - - - - - - -

はじめに
--------

型プロバイダーの基本的な作成手順は以下の通りです：

- `ProvidedTypes.fs` と `ProvidedTypes.fsi` のファイルを [F# 3.0 Sample Pack][id03] から取得してプロジェクトに追加する
- [Tutorial: Creating a Type Provider][id04] の手順に従い、定義したいAPIに応じて`ProvidedTypeDefinition`, `ProvidedProperty`, `ProvidedMethod`などを作成する

これらを読み終えたら以下に進んでください。

基底の表現を隠ぺいする
----------------------

一番単純なケースとしては基底の表現がない場合です。
その場合には公開する型を`obj`に設定するだけでよいです。
また、公開するメソッド用の`InvokeCode`や`GetterCode`プロパティには
`<@@ ... @@>`というコードクォートを指定することによって、
メソッドに渡される`this`引数を完全に無視できるようになります。
コンパイル後は公開する型が何であろうとも、その型に関する情報は直接公開されず、すべて消去されます。
残されるのはコードクォート内で定義したコードだけです。
実際、型プロバイダーが提供するものは、これまで型プロバイダーを使わずとも実装することのできたものに対するシンタックスシュガーあるいはIntelliSenseサポートにすぎません。

しかしほとんどの場合に該当しますが、型プロバイダーには何らかの基底の表現があり、何らかのデータを保持するような型を作成することになるでしょう。
その場合、ロジックの大半はこの型の中で実装し、この型を公開する型の基底型とすることになります。
そうするとF#コンパイラはこれらの基底型を型プロバイダーが定義されているアセンブリ内にコピーして埋め込みます。
つまり、型プロバイダーを参照すると、単にシンタックスシュガーが追加されるだけではなく、何らかの新しいコードも追加されるというわけです。

想像する通り、基底型のメンバーは公開型に対するIntelliSenseにすべて表示されます。
一部のシチュエーションではこれは期待通りのすばらしい挙動です。
しかし場合によっては（おそらくはたいていの場合に該当しますが）、
既存の型プロバイダーがユーザーに対して適切なAPIしか公開していないのと同じように、
公開するメソッドやプロパティを実装するためだけの内部コードとしておき、これらの型を外部に公開したくないこともあります。
この状況はたとえば現行バージョンの [TryF#上のWorld Bank型プロバイダー][id05] で確認できます。
`data`の直後でドットを入力すると、IntelliSenseには`Countries`や`Regions`の他に、
直接使用することを想定していないような`_GetCountries`や`_GetRegions`、あるいはその他のメンバーも表示されます。
これらを表示すべきでないことは明らかです。
ではどうすればよいのでしょうか？

- OOの経験がある場合、まず思いつくのはメンバーをprotectedにすることですが、
  F#には`protected`修飾子がありません。また、もしこの修飾子があったとしても、
  独自の型から直接派生した型を作成しているわけではなく、またいずれの型も消去されるためうまくいきません。
- また、実行時における表現型はF#コンパイラがコピーをするとはいっても、型プロバイダーのアセンブリ内にあって、型プロバイダーを使用するアセンブリにあるわけではないため、
  メンバーを`internal`にすることもできません。
- C#の場合、メソッドやプロパティに`[System.ComponentModel.Browsable(false)]`を指定すると
  IntelliSenseで非表示にできますが、残念なことにこれはF#では機能しません。
- 表示したいメンバーを持つインターフェイスを定義して、このインターフェイスを実行時の表現型で実装することはできます。
  こうすると、F#ではインターフェイスを明示的に実装しなければならないため、IntelliSenseで非表示にできます。
  しかしstaticメンバーについては効果がありません。
- 消去型のコンストラクタはIntelliSenseに表示されないため、`Parse`や`Load`といったstaticメソッドをコンストラクタに書き換えてしまうとよいでしょう。
- 実行時の表現型と同じ引数をとり、リターンされる型だけが異なるような`ProvidedMethod`を定義する場合、内部用の型に対するメソッドは表示されないため、特別な処理をする必要はありません。
- `ProvidedTypeDefinition`には`HideObjectMethods`プロパティがあり、
  このプロパティを使用することで`GetHashCode()`や`GetType()`、`ToString()`、`Equals`メソッドをIntelliSenseで表示しないようにできます。
  しかし基底型がこれらのいずれかをオーバーライドしている場合には常に表示されます。
  この問題に対処する方法は今もまだわかっていません。

[FSharp.Data][id02] バージョンのWorld Bank（およびCSVやXML、JSON、Freebase）型プロバイダーでは、
インターフェイスやコンストラクタを使用して公開したくないメンバーを非表示にしているため、
`_Something`といったメンバーは表示されません。

- - - - - - - - - -

アセンブリを2つに分割する
---------------------

型プロバイダーが巨大になると、実行時とデザイン時のコンポーネントを2つのアセンブリに分割することになるでしょう。
また、デザイン時のアセンブリを1つにしておき、複数の実行時アセンブリを各プロファイルに用意することで
複数の.NET Frameworkプロファイル（たとえばSilverlightやポータブルクラスライブラリ）を
サポートできるようにする必要があるかもしれません。

この場合、実行時アセンブリには複数のバージョンがあるため、デザイン時アセンブリは単に実行時アセンブリを参照すればよいというわけにはいきません。
また、複数のプロファイルをサポートする必要が無かったとしても、型プロバイダーのデザイン時アセンブリは
F#コンパイラのプロセス内でロードされるため、デザイン時コンポーネントに依存するすべてのアセンブリが
正しく機能しなくなります。
この問題に対処するためには、デザイン時アセンブリと実行時アセンブリとの間に依存関係を持たせないようにして、
デザイン時アセンブリ内に実行時アセンブリ用の全ファイルを直接取り込んでしまえばよいでしょう。
これによりデザイン時コンポーネントのファイルサイズが増加しますが、
最終的なアプリケーションにすべてのDLLが同梱されるわけではないため、大きな問題にはならないでしょう。

しかしこの方法の場合、1つ大きな問題が残ります。
それはコードクォートが機能しなくなるという問題です。
何故かというと、間違ったアセンブリの型を参照しているからです。
そのため、型プロバイダーに渡される`TypeProviderConfig`型に定義された`RuntimeAssembly`プロパティに対して、
`Assembly.LoadFrom`を使用してロードした実行時コンポーネントを指定し、
`Assembly.GetType`を使用して必要な型を取得した後、
この型を使用して式を適切に構成することになります。
[F# 3.0 Sample Pack][id03] のほとんどのサンプルではこの方法を使用しています。
すばらしい！問題は解決されました。そうでしょう？

話を1月に戻すと、当時私はWindow Phoneや Windows 8アプリで [FSharp.Data][id02] を
使用したかったので、ポータブルクラスライブラリをサポートできるようにしようとしていました。
コードクォートを書き換えて、リフレクションAPIなどを使用して手動で式を作成するような変更を
いくつか行った時点で、私は思い直しました：

「駄目だ！
かつては型セーフなコードクォートだったおかげですばらしくて簡潔なコードだったのに、
今は文字列に頼ったリフレクションAPIを使っているせいでエラーの起こりやすい
ひどいコードに書き換えようとしているじゃないか。
なんという退化だろうか。
もっといい方法があるはずだ。」

その後いくつかの失敗があったり、github issueで数多くの議論を交わした結果、
ようやく解決策が見つかりました。
コードクォートを処理して、型が正しいアセンブリを参照するようにすればよいのです。
この処理を行っているのが [ここ][id06] にある`AssemblyReplacer`です。
このコードはその他の [FSharp.Data][id02] にはほとんど依存しないため、
必要であれば自身の型プロバイダープロジェクトに単にコピーして使用することもできるでしょう。

型プロバイダーをデザイン時と実行時アセンブリに分割しない場合であっても、
コードクォートが使用できず、独自に式を作成しなければならないことがあります。
これは型プロバイダーで作成した型を型引き数とするようなジェネリックを使用する場合だけが該当します。
この場合、 [ここ][id07] にある [Tomas][id08] が実装した`QuotationBuilder`内の
素敵な動的演算子`(?)`を使用するとよいでしょう。

次回予告
--------

- 型プロバイダーのデバッグ方法
- 複数の.NET Frameworkプロファイルをサポートする方法
- 型プロバイダーの開発中によく起こるエラーについて

[id00]: http://blog.codebeside.org/blog/2013/05/13/building-type-providers-part1/ "Building Type Providers - Part 1"
[id01]: http://blogs.msdn.com/b/dsyme/archive/2013/01/30/twelve-type-providers-in-pictures.aspx "All your types are belong to us"
[id02]: http://fsharp.github.com/FSharp.Data/ "FSharp.Data"
[id03]: http://fsharp3sample.codeplex.com/ "F# 3.0 Sample Pack"
[id04]: http://msdn.microsoft.com/en-gb/library/hh361034.aspx "Tutorial: Creating a Type Provider"
[id05]: http://www.tryfsharp.org/Learn/data-science#world-bank-type-provider "World Bank type provider on TryF#"
[id06]: https://github.com/fsharp/FSharp.Data/blob/master/src/Providers/AssemblyReplacer.fs "AssemblyReplacer"
[id07]: https://github.com/fsharp/FSharp.Data/blob/master/src/Providers/QuotationBuilder.fs "QuotationBuilder"
[id08]: http://tomasp.net/ "TomasP.net"
